[
["index.html", "R中的统计模拟 前言 致谢", " R中的统计模拟 wang 2019-08-06 前言 关于R的基础语法,可以在网上或者书籍中学习. Github W3Cschool Advanced R 这里只是总结一些统计模拟中遇到的问题,以及实用的技巧. 致谢 这个页面的建立基于 knitr (Xie 2015)和 bookdown (Xie 2019)。以下是我的 R 进程信息： sessionInfo() ## R version 3.6.0 (2019-04-26) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS Mojave 10.14.6 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets ## [6] methods base ## ## loaded via a namespace (and not attached): ## [1] compiler_3.6.0 magrittr_1.5 bookdown_0.11 ## [4] tools_3.6.0 htmltools_0.3.6 rstudioapi_0.10 ## [7] yaml_2.2.0 Rcpp_1.0.1 stringi_1.4.3 ## [10] rmarkdown_1.13 knitr_1.23 stringr_1.4.0 ## [13] xfun_0.7 digest_0.6.19 evaluate_0.14 参考文献 "],
["author.html", "作者简介", " 作者简介 统计学学生. 主要用R和tex. "],
["section-2.html", "第 1 章 常用函数及常见错误 1.1 产生数据 1.2 定义运算符 1.3 自动纠错 1.4 predict函数 1.5 保存结果 1.6 结果输出 1.7 模拟流程", " 第 1 章 常用函数及常见错误 1.1 产生数据 在进行模拟时, 我们经常会需要生成数据. 这里以正态分布为例, 说明如 何产生数据. 在 R 中, 每种分布都会有以下 4 个函数: 概率密度函数: dnorm(x, mean = 0, sd = 1, log = FALSE) 累计分布函数: pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 分位数函数: qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) 随机数产生: rnorm(n, mean = 0, sd = 1): 其中前 3 个函数都支持向量输入, 即计算一组取值的概率密度、累计分布、 分位数. 最后一个函数常用来生成数据,n 即产生数据的个数. 如果需要生成 多维正态分布, 需要调用 MASS 包中的 *mvrnorm(n = 1, mu, Sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE), 其中 Sigma 是指定的协方差矩阵. 1.2 定义运算符 空间模型 (SAR) 中, 会出现对角块矩阵 \\[ \\mathbf{W}=\\left(\\begin{array}{cccc}{\\mathbf{M}} &amp; {} &amp; {} &amp; {} \\\\ {} &amp; {\\mathbf{M}} &amp; {} &amp; {} \\\\ {} &amp; {} &amp; {\\ddots} &amp; {} \\\\ {} &amp; {} &amp; {} &amp; {\\mathbf{M}}\\end{array}\\right) \\] M 作为权重矩阵, 这种形式的矩阵可以利用克罗内克积 (Kronecker product, 符号为\\(\\otimes\\)) 在 R 中很方便的产生,命令是%x%. 可以写成\\[\\mathbf{W} = \\mathbf{I} \\otimes \\mathbf{M}.\\] diag(3)%x%matrix(1:6,2,3) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] ## [1,] 1 3 5 0 0 0 0 0 0 ## [2,] 2 4 6 0 0 0 0 0 0 ## [3,] 0 0 0 1 3 5 0 0 0 ## [4,] 0 0 0 2 4 6 0 0 0 ## [5,] 0 0 0 0 0 0 1 3 5 ## [6,] 0 0 0 0 0 0 2 4 6 这是借助自定义运算符实现的.自定义运算符是一种特殊的函数,当参数只有两个变量时,可以进行定义.用法如下: &#39;%myop%&#39;&lt;-function(a,b){a^b+b^a} 2%myop%3 ## [1] 17 利用自定义运算符,可以实现很方便的功能.R中矩阵乘法(%*%)、Kronecker乘积(%x%)都是这样实现的.另外还有整除(%/%)和取余(%%) 9%/%4 ## [1] 2 13%%3 ## [1] 1 1.3 自动纠错 当我们输入的命令不规范时,R会自动纠正,以保证程序正常运行. 比如看下面的例子: 1:4 - 1:2 ## [1] 0 0 2 2 1:5-1:2 ## Warning in 1:5 - 1:2: longer object length is not a ## multiple of shorter object length ## [1] 0 0 2 2 4 当运算的向量长度不一致时,R会自动重复短的向量,使之长度与另外的向量长度相同进行运算.但是当长度是整数倍当时候,不会有任何提示. 再看下面当例子: matrix(1:9,3,3)*(1:3) ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 4 10 16 ## [3,] 9 18 27 本来想计算矩阵与向量的乘积,但是错误使用了*, 未使用矩阵乘法%*%,R也可以计算返回一个矩阵,不会有warning. 当条件为向量是,只会判断第一个值: if( 1 &lt;= 1:3) print(&quot;真&quot;) else print(&quot;假&quot;) ## Warning in if (1 &lt;= 1:3) print(&quot;真&quot;) else print(&quot;假&quot;): ## the condition has length &gt; 1 and only the first element ## will be used ## [1] &quot;真&quot; 如果条件为向量,应该使用all或者any函数: all(1 &lt;= 1:3) ## [1] TRUE all(2 &lt;= 1:3) ## [1] FALSE 所有都真的时候返回TRUE. any(4 &lt;= 1:3) ## [1] FALSE any(2 &lt;= 1:3) ## [1] TRUE 只要有一个为真就返回TRUE. 1.4 predict函数 当我们拟合好一个模型时,下一步要做的就是评价模型好坏或者对新数据预测.这都需要将新的输入值带入模型中计算,得到预测值.区别只是有没有真值对比.对于简单模型,我们当然可以直接提取系数,自己计算预测值,但是当模型复杂时(比如时间序列模型),就不太容易操作. R借助泛型函数1,编写模型都会提供summary、predict、plot等函数方便调用.但是在学习过程中发现经常会不小心错误使用,特此单独说明一下.下面以线性模型为例,先看正确的使用方法: n=100;p=3;beta=c(1,2,3); X = matrix(rnorm(n*p),n,p) Y = X%*%beta + rnorm(n) trainlist = sample(1:n,70) regData = data.frame(Y,X) fitmodel = lm(Y~.,data=regData[trainlist,]) pe = predict(fitmodel,newdata=regData[-trainlist,]) sum((pe-regData[-trainlist,1])^2)/length(pe) ## [1] 0.9258 关键点: 所有数据存在一个数据框中 通过下标控制训练集和测试集的数据 错误程序1: n=100;p=3;beta=c(1,2,3); X = matrix(rnorm(n*p),n,p) Y = X%*%beta + rnorm(n) fitmodel = lm(Y~X) X2 = matrix(rnorm(n*p),n,p) Y2 = X2%*%beta + rnorm(n) #predict(fitmodel,newdata = X2)数据格式错误,不能执行 pe = predict(fitmodel,newdata = data.frame(X2)) sum((pe-Y2)^2)/length(Y2) ## [1] 26.61 这个程序能明显看出问题,误差不应该这么大,但是程序没有任何warning. 错误程序2: n=100;p=3;beta=c(1,2,3); X = matrix(rnorm(n*p),n,p) Y = X%*%beta + rnorm(n) fitmodel = lm(Y~X) X2 = matrix(rnorm(0.2*n*p),0.2*n,p) Y2 = X2%*%beta + rnorm(0.2*n) pe = predict(fitmodel,newdata = data.frame(X2)) ## Warning: &#39;newdata&#39; had 20 rows but variables found have ## 100 rows length(pe) ## [1] 100 修改测试数据的条数,使之与训练集数据量不同,可以发现warning.提示我们数据行数不一样.并且我们测试集合X2是20行,但是预测值pe返回的是100个值.问题在于predict函数使用不正确. 我们用all指令查看: all(predict(fitmodel)==predict(fitmodel,newdata = data.frame(X2))) ## Warning: &#39;newdata&#39; had 20 rows but variables found have ## 100 rows ## [1] TRUE 就是说我们输入的参数没起到作用. 查看函数说明2 ?predict.lm 参数 说明 object Object of class inheriting from “lm” newdata An optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used. … newdata不是必要的参数,当缺失时候会使用拟合模型的数据. 至于为什么输入的数据不能正确识别,因为名字不一样.R中参数的传递都是通过名字,我们在拟合lm时候,解释变量的名字叫‘X’,所以传入‘X2’不会识别到.如果把‘X2’改名成‘X’,即可正确预测3,比如看下面的程序: n=100;p=3;beta=c(1,2,3); X = matrix(rnorm(n*p),n,p) Y = X%*%beta + rnorm(n) fitmodel = lm(Y~X) X = matrix(rnorm(0.2*n*p),0.2*n,p) Y2 = X%*%beta + rnorm(0.2*n) pe = predict(fitmodel,newdata = data.frame(X)) sum((Y2-pe)^2)/length(pe) ## [1] 0.6031 通过以上例子,想说明当程序的结果和预期不一致时.当然可能是我们的方法不对,但是也有可能是调用函数的方式出了问题.比如线性规划求解的lp函数,默认在正半轴求解4. 1.5 保存结果 我们重复了M次实验(运行几小时或者几天),计算了几个指标.但是后续通过阅读其他文献或者老师的建议,需要计算一个新的指标.这时候,就可以打开之前保存好的运行结果,只需要进行分析画图即可,不需要重新运行程序5. getwd() setwd() save.image() getwd,setwd分别用于获取、设置当前的工作目录.有时候我们保存了结果,但是不知道存到哪里,可以通过getwd查看当前的工作目录.当然,最好是在程序执行前,手动设置好工作目录. save.image用于保存工作空间,可以借助对于字符串操作函数paste等设置文件名. 1.6 结果输出 R只是我们模拟使用的工具,模拟结果需要以图表的形式在文章中展现.对于图片,只要单独保存成文件,在文章中插入即可.对于表格,如果不借助工具,会很耗时.这里我们通过xtable包中的函数,可以将表格数据转换成 LaTeX 内的表格形式. 这里顺便介绍一下R中package的安装和加载.不管是在R GUI中,还是在Rstudio中,都可以通过点选菜单进行安装.如果通过命令安装,如下 install.packages(&quot;xtable&quot;) 安装后,并不能直接使用.需要通过library命令加载后才能使用.一个package中包含很多函数和数据,有时候我们只需要使用其中的一个函数,不需要加载整个包.这时候可以通过下面这样,直接调用某个包中的函数,xtable有一些参数可以设置输出的格式,比如下面指定了小数部分位数: xtable::xtable(matrix(rnorm(15),3,5),digits=5) ## % latex table generated in R 3.6.0 by xtable 1.8-4 package ## % Tue Aug 6 08:55:19 2019 ## \\begin{table}[ht] ## \\centering ## \\begin{tabular}{rrrrrr} ## \\hline ## &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\\\ ## \\hline ## 1 &amp; -1.40045 &amp; 0.78974 &amp; -1.49898 &amp; -0.49517 &amp; 0.91428 \\\\ ## 2 &amp; 0.14569 &amp; 0.76534 &amp; 1.04113 &amp; 0.68360 &amp; 0.73087 \\\\ ## 3 &amp; -0.39239 &amp; 0.15512 &amp; -0.83092 &amp; 0.77105 &amp; -0.71431 \\\\ ## \\hline ## \\end{tabular} ## \\end{table} 这只是最基础的表格,LaTeX中定制表头可以在这查看. 1.7 模拟流程 程序在 这里 查看,其中最后被/***R */夹住的部分是R程序,每次加载后会自动执行,方便调试.↩ 垃圾回收（英语：Garbage Collection，缩写为GC），在计算机科学中是一种自动的存储器管理机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为垃圾回收。↩ 后续重新整理成Rmd格式.↩ 省略了常数系数.↩ 目前只有单次二项分布的程序正确.完整的程序可以从这里下载.↩ "],
["section-9.html", "第 2 章 参数估计 2.1 M估计 2.2 Z估计", " 第 2 章 参数估计 对于参数估计的模拟,主要分成三步: 生成数据; 估计参数; 评价估计好坏. 对于生成数据,在阅读文献时,文章中会明确给出如何产生.我们不必多费周折.在设计我们自己的模拟实验时,多借鉴其他文献中的例子.一方面方便和其他文献进行比较,另一方面,可以避免落入陷阱6. 对于评价估计好坏,有限维离散参数一般采取\\(\\left\\|\\hat{\\boldsymbol{\\theta}}-\\boldsymbol{\\theta}_{0}\\right\\|,\\)无穷维函数一般采取\\(\\int\\left(\\hat{m}(x)-m_{0}(x)\\right)^{2} d x.\\) 估计量通过解估计方程得到,根据方程的形式,分为M估计量和Z估计量,下面分别说明. 2.1 M估计 定义:极大化(或极小化)目标函数得到参数估计值. \\[ M_{n}(\\theta)=\\frac{1}{n} \\sum_{i=1}^{n} m_{\\theta}\\left(X_{i}\\right) \\] \\[ \\hat{\\theta}=\\arg \\max_{\\theta \\in \\Theta} M_{n}(\\theta) \\] 其中\\(m_{\\theta}\\left(X_{i}\\right)\\)为已知函数.特别的,如果\\(M_n(\\theta)\\)可导,M估计量和Z估计量有等价形式. 下面以线性模型为例:\\(\\boldsymbol{Y}=\\boldsymbol{X}^{T}\\boldsymbol{\\theta}+\\boldsymbol{\\varepsilon}\\) 考虑最小二乘估计,取\\(m_{\\theta}\\left(\\boldsymbol{X}_{i}\\right)=-\\left(Y_{i}-\\boldsymbol{X}_{i}^{T} \\boldsymbol{\\theta}\\right)^{2}\\)7,则 \\[ \\begin{aligned} M_{n}(\\theta)&amp;=-\\frac{1}{n} \\sum_{i=1}^{n}\\left(Y_{i}-\\boldsymbol{X}_{i}^{T} \\boldsymbol{\\theta}\\right)^{2}\\\\ &amp;=-\\frac{1}{n}\\left(\\boldsymbol{Y}-\\boldsymbol{X}^{T} \\boldsymbol{\\theta}\\right)^{T}\\left(\\boldsymbol{Y}-\\boldsymbol{X}^{T} \\boldsymbol{\\theta}\\right)\\\\ &amp;=-\\frac{1}{n}\\left(\\boldsymbol{\\theta}^{T} \\boldsymbol{X} \\boldsymbol{X}^{T} \\boldsymbol{\\theta}-2 \\boldsymbol{Y}^{T} \\boldsymbol{X}^{T} \\boldsymbol{\\theta}+\\boldsymbol{Y}^{T} \\boldsymbol{Y}\\right) \\end{aligned} \\] 其中最后一项是与\\(\\boldsymbol{\\theta}\\)无关的常数项,可以不考虑,进而可以整理成如下的二次规划问题: 利用quadprog包中的函数可以求解 library(quadprog) n=100;p=3;beta=c(1,-2,3); X = matrix(rnorm(n*p),n,p) Y = X%*%beta + rnorm(n) lm(Y~X+0)$coef == solve.QP(Dmat = t(X)%*%X/n, dvec = (t(Y)%*%X)/n, Amat = matrix(0,p,p))$solution ## X1 X2 X3 ## FALSE FALSE FALSE 可以看到结果显示不相等,但是如果我们打印出来显示: lm(Y~X+0)$coef ## X1 X2 X3 ## 1.122 -2.070 2.893 solve.QP(Dmat = t(X)%*%X/n, dvec = (t(Y)%*%X)/n, Amat = matrix(0,p,p))$solution ## [1] 1.122 -2.070 2.893 可以看到结果是一致的.这是由于计算机存储数字精度引起的.比如我们查看 sum(abs(lm(Y~X+0)$coef - solve.QP(Dmat = t(X)%*%X/n, dvec = (t(Y)%*%X)/n, Amat = matrix(0,p,p))$solution)) ## [1] 3.109e-15 另外,我们可以用all.equal这个函数设置容忍的误差值,判断近似相等: all.equal(unname(lm(Y~X+0)$coef), solve.QP(Dmat = t(X)%*%X/n, dvec = (t(Y)%*%X)/n, Amat = matrix(0,p,p))$solution ,tolerance=1e-10) ## [1] TRUE all.equal(unname(lm(Y~X+0)$coef), solve.QP(Dmat = t(X)%*%X/n, dvec = (t(Y)%*%X)/n, Amat = matrix(0,p,p))$solution ,tolerance=1e-20) ## [1] &quot;Mean relative difference: 5.109e-16&quot; 下面考虑稍复杂的情况,取 \\(m_{\\theta}\\left(\\boldsymbol{X}_{i}\\right)=\\rho_{\\tau}\\left(y_{i}-\\boldsymbol{X}_{i}^{T} \\boldsymbol{\\theta}\\right)\\),其中 \\(\\rho_{\\tau}(t)=t\\left(\\tau-I_{\\{t&lt;0\\}}\\right)\\). 这称为分位数回归,详细的推导过程可以在分位数回归总结查看8. 这里缺少一个M估计迭代求解的例子 2.2 Z估计 定义:解一个等于0的方程得到参数估计. \\[ \\Psi_{n}(\\theta)=\\frac{1}{n} \\sum_{i=1}^{n} \\psi_{\\theta}\\left(X_{i}\\right)=0, \\] 其中\\(\\psi_{\\theta}\\left(X_{i}\\right)\\)为已知函数. \\(\\hat{\\theta}\\)为 \\(\\Psi_{n}(\\theta)=0\\)的解. 回到线性模型最小二乘的例子,由于目标函数存在导数,可以转化成一个Z估计量.取 \\(\\psi_{\\theta}\\left(X_{i}\\right)=m_{\\theta}&#39;\\left(X_{i}\\right)=2\\boldsymbol{X}_{i}^{T} \\left(Y_{i}-\\boldsymbol{X}_{i}^{T} \\boldsymbol{\\theta}\\right)\\) 则9 \\[ \\Psi_{n}(\\theta)=\\frac{1}{n} \\sum_{i=1}^{n}\\boldsymbol{X}_{i}^{T} \\left(Y_{i}-\\boldsymbol{X}_{i}^{T} \\boldsymbol{\\theta}\\right) =\\boldsymbol{X} \\boldsymbol{X}^{T} \\boldsymbol{\\theta}-\\boldsymbol{X} \\boldsymbol{Y}=0, \\] 进而得到参数估计值为:\\(\\hat{\\boldsymbol{\\theta}}=\\left(\\boldsymbol{X} \\boldsymbol{X}^{T}\\right)^{-1} \\boldsymbol{X} \\boldsymbol{Y}.\\) 通过下面的程序验证: library(quadprog) all.equal(solve.QP(Dmat = t(X)%*%X/n, dvec = (t(Y)%*%X)/n, Amat = matrix(0,p,p))$solution, as.numeric(solve(t(X)%*%X)%*%t(X)%*%Y)) ## [1] TRUE 下面是一个迭代求解Z估计量的例子10. 补充哪一篇参考文献 source(&quot;code/glm.R&quot;) n=500 m1=2 m2=2 m3=2 m=m1+m2+m3 beta=c(rep(-1,m1),rep(0,m2),rep(1,m3)) X=runif(n*m,-1,1) X=matrix(X,n,m) eta=X%*%beta mu=1/(1+exp(-eta)) # Y~B(1,p) Y=runif(n) Y[Y&gt;=mu]=0 Y[Y&gt;0]=1 glm(Y~X+0,family=binomial(link=&quot;logit&quot;)) ## ## Call: glm(formula = Y ~ X + 0, family = binomial(link = &quot;logit&quot;)) ## ## Coefficients: ## X1 X2 X3 X4 X5 X6 ## -1.030 -0.762 0.453 -0.304 0.823 0.958 ## ## Degrees of Freedom: 500 Total (i.e. Null); 494 Residual ## Null Deviance: 693 ## Residual Deviance: 583 AIC: 595 myglm(Y,X,distribution = &quot;binom&quot;) ## Loading required package: MASS ## $theta ## [,1] ## [1,] -0.9946 ## [2,] -0.7397 ## [3,] 0.4485 ## [4,] -0.2557 ## [5,] 0.8269 ## [6,] 0.8908 ## ## $steps ## [1] 4 可以看到和真值相差不大,但是很快收敛. 程序在 这里 查看,其中最后被/***R */夹住的部分是R程序,每次加载后会自动执行,方便调试.↩ 垃圾回收（英语：Garbage Collection，缩写为GC），在计算机科学中是一种自动的存储器管理机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为垃圾回收。↩ 后续重新整理成Rmd格式.↩ 省略了常数系数.↩ 目前只有单次二项分布的程序正确.完整的程序可以从这里下载.↩ "],
["section-10.html", "第 3 章 假设检验", " 第 3 章 假设检验 假设检验部分模拟相对简单,只需要在估计出参数值后,按照检验统计量的形式正确计算即可.主要难点在于构造检验统计量以及给出检验统计量的渐近分布. 常用的办法是通过自助法(bootstrap)估计分布. 我们以最简单的二项分布为例,说明一些假设检验中的概念. X p=0.5 p=0.6 p=0.7 p=0.8 p=0.9 0 0.0010 0.0001 0.0000 0.0000 0.0000 1 0.0098 0.0016 0.0001 0.0000 0.0000 2 0.0439 0.0106 0.0014 0.0001 0.0000 3 0.1172 0.0425 0.0090 0.0008 0.0000 4 0.2051 0.1115 0.0368 0.0055 0.0001 5 0.2461 0.2007 0.1029 0.0264 0.0015 6 0.2051 0.2508 0.2001 0.0881 0.0112 7 0.1172 0.2150 0.2668 0.2013 0.0574 8 0.0439 0.1209 0.2335 0.3020 0.1937 9 0.0098 0.0403 0.1211 0.2684 0.3874 10 0.0010 0.0060 0.0282 0.1074 0.3487 显著水平=第一类错误=\\(\\alpha\\):为图中红色区域的面积 第二类错误=\\(\\beta\\):为图中蓝色区域的面积 功效=势=power=\\(1- \\beta\\):为图中蓝色曲线下空白面积 检验的相合性: 在\\(H_0\\)下, 拒绝概率(size)收敛到\\(\\alpha.\\) 在\\(H_1\\)下, 拒绝概率(power)收敛到\\(1.\\) "],
["section-11.html", "第 4 章 进阶技巧 4.1 apply函数族 4.2 并行 4.3 Rcpp", " 第 4 章 进阶技巧 程序的可读性和执行效率是两个很重要的要求.这一章主要介绍如何提高这两点. 4.1 apply函数族 apply并不能提高执行效率,只能使代码简洁易读. 详细的介绍可以在apply函数族介绍查看,其中给了一些简单的例子.下面演示一下稍微复杂的用法. 对矩阵按列进行操作,每列的奇数项求和,偶数项求和: m &lt;- matrix(1:12,4,3) m ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 apply(m, 2, tapply,rep(1:2,2), sum) ## [,1] [,2] [,3] ## 1 4 12 20 ## 2 6 14 22 对矩阵按列进行操作,每列前两项求和,后两项求和: apply(m, 2, tapply,rep(1:2,each=2), sum) ## [,1] [,2] [,3] ## 1 3 11 19 ## 2 7 15 23 下面看一个3维情况的例子. a &lt;- array(1:24,dim = c(2,3,4)) a ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 7 9 11 ## [2,] 8 10 12 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 13 15 17 ## [2,] 14 16 18 ## ## , , 4 ## ## [,1] [,2] [,3] ## [1,] 19 21 23 ## [2,] 20 22 24 固定1个维度,对另外2个维度求和: apply(a,1,sum) ## [1] 144 156 这样看起来不太直观,我们利用aperm函数调整数组的维度顺序: aperm(a,c(2,3,1)) ## , , 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 1 7 13 19 ## [2,] 3 9 15 21 ## [3,] 5 11 17 23 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 2 8 14 20 ## [2,] 4 10 16 22 ## [3,] 6 12 18 24 固定2个维度,对1个维度求和: apply(a,c(2,3),sum) ## [,1] [,2] [,3] [,4] ## [1,] 3 15 27 39 ## [2,] 7 19 31 43 ## [3,] 11 23 35 47 固定2个维度,对1个维度分组求和: apply(a,c(1,2),tapply,rep(c(-1,-2),2), sum) ## , , 1 ## ## [,1] [,2] ## -2 26 28 ## -1 14 16 ## ## , , 2 ## ## [,1] [,2] ## -2 30 32 ## -1 18 20 ## ## , , 3 ## ## [,1] [,2] ## -2 34 36 ## -1 22 24 对第三个维度奇数项、偶数项分别求和(奇数项是-1组,偶数项是-2组). 4.2 并行 单次模拟时间越长,重复次数越多,并行得到的提升越明显. R中有很多并行包,可以在 不同并行包比较查看对比. 这里介绍的foreach是比较友好的一个包. 下面以线性模型估计系数为例,给出示例代码. sim_single可以在 单次估计程序 查看.其中SLP参数用于增加单次模拟的计算量(运行时间). 4.2.1 低重复次数,低计算量 source(&quot;code/parallel-demo.R&quot;) library(&quot;foreach&quot;) library(&quot;doParallel&quot;) beta0 = c(1,-2,3) N = c(50,100,200) distribution= c(rnorm,rcauchy) SIM = 500 tstart=Sys.time() cl &lt;- makeCluster(detectCores()) registerDoParallel(cl) result &lt;- foreach(n=N,.combine = rbind) %:% foreach(dst=distribution,.combine = c) %:% foreach(i=1:SIM,.combine = &#39;+&#39;, .packages = c(&quot;MASS&quot;) )%dopar%{ sim_single(n,beta0,SLP=FALSE,mydist = dst) } stopImplicitCluster() t.end=Sys.time() t.end-tstart ## Time difference of 2.182 secs result/SIM ## [,1] [,2] [,3] [,4] [,5] [,6] ## result.1 0.9988 -2.006 3.002 -0.05712 -1.969 1.962 ## result.2 0.9979 -1.996 2.997 2.41988 -4.019 1.518 ## result.3 0.9985 -2.002 3.007 0.62494 -2.432 2.903 把申请cluster的命令去掉,%dopar%换成%do%程序就会按串行执行 source(&quot;code/parallel-demo.R&quot;) library(&quot;foreach&quot;) library(&quot;doParallel&quot;) beta0 = c(1,-2,3) N = c(50,100,200) distribution= c(rnorm,rcauchy) SIM = 500 tstart=Sys.time() #cl &lt;- makeCluster(detectCores()) #registerDoParallel(cl) result &lt;- foreach(n=N,.combine = rbind) %:% foreach(dst=distribution,.combine = c) %:% foreach(i=1:SIM,.combine = &#39;+&#39;, .packages = c(&quot;MASS&quot;) )%do%{ sim_single(n,beta0,SLP=FALSE,mydist = dst) } #stopImplicitCluster() t.end=Sys.time() t.end-tstart ## Time difference of 2.285 secs result/SIM ## [,1] [,2] [,3] [,4] [,5] [,6] ## result.1 1.0005 -1.997 3.003 7.4661 -4.5211 -0.2274 ## result.2 0.9939 -2.002 3.003 -0.8143 -0.4892 4.1754 ## result.3 1.0036 -2.002 2.996 0.4728 -1.9347 0.9797 4.2.2 高重复次数,低计算量 增加到1000次. 并行: source(&quot;/Users/wang/Documents/GitHub/Simulation-in-R/code/parallel-demo.R&quot;) library(&quot;foreach&quot;) library(&quot;doParallel&quot;) beta0 = c(1,-2,3) N = c(50,100,200) distribution= c(rnorm,rcauchy) SIM = 1000 tstart=Sys.time() cl &lt;- makeCluster(detectCores()) registerDoParallel(cl) result &lt;- foreach(n=N,.combine = rbind) %:% foreach(dst=distribution,.combine = c) %:% foreach(i=1:SIM,.combine = &#39;+&#39;, .packages = c(&quot;MASS&quot;) )%dopar%{ sim_single(n,beta0,SLP=FALSE,mydist = dst) } stopImplicitCluster() t.end=Sys.time() t.end-tstart ## Time difference of 3.403 secs result/SIM ## [,1] [,2] [,3] [,4] [,5] [,6] ## result.1 1.007 -2.013 2.999 0.1556 -2.407 3.176 ## result.2 1.008 -2.002 2.996 0.7327 -2.565 3.577 ## result.3 1.000 -2.000 2.997 2.5792 -2.113 2.966 串行: source(&quot;code/parallel-demo.R&quot;) library(&quot;foreach&quot;) library(&quot;doParallel&quot;) beta0 = c(1,-2,3) N = c(50,100,200) distribution= c(rnorm,rcauchy) SIM = 1000 tstart=Sys.time() #cl &lt;- makeCluster(detectCores()) #registerDoParallel(cl) result &lt;- foreach(n=N,.combine = rbind) %:% foreach(dst=distribution,.combine = c) %:% foreach(i=1:SIM,.combine = &#39;+&#39;, .packages = c(&quot;MASS&quot;) )%do%{ sim_single(n,beta0,SLP=FALSE,mydist = dst) } #stopImplicitCluster() t.end=Sys.time() t.end-tstart ## Time difference of 4.604 secs result/SIM ## [,1] [,2] [,3] [,4] [,5] [,6] ## result.1 1.0017 -1.999 3.000 1.5062 -2.2061 2.577 ## result.2 1.0032 -1.990 2.997 3.9836 -0.5012 3.743 ## result.3 0.9991 -1.997 2.997 0.8568 -2.0615 2.718 4.2.3 低重复次数,高计算量 增加每次模拟的计算量,延长单次模拟的时间. 并行: source(&quot;/Users/wang/Documents/GitHub/Simulation-in-R/code/parallel-demo.R&quot;) library(&quot;foreach&quot;) library(&quot;doParallel&quot;) beta0 = c(1,-2,3) N = c(50,100,200) distribution= c(rnorm,rcauchy) SIM = 500 tstart=Sys.time() cl &lt;- makeCluster(detectCores()) registerDoParallel(cl) result &lt;- foreach(n=N,.combine = rbind) %:% foreach(dst=distribution,.combine = c) %:% foreach(i=1:SIM,.combine = &#39;+&#39;, .packages = c(&quot;MASS&quot;) )%dopar%{ sim_single(n,beta0,SLP=TRUE,mydist = dst) } stopImplicitCluster() t.end=Sys.time() t.end-tstart ## Time difference of 9.387 secs result/SIM ## [,1] [,2] [,3] [,4] [,5] [,6] ## result.1 1.0101 -2.001 2.994 1.373 -1.572 2.844 ## result.2 0.9968 -2.013 2.992 3.813 -4.572 8.934 ## result.3 0.9996 -1.997 3.000 7.350 -4.860 3.662 串行: source(&quot;code/parallel-demo.R&quot;) library(&quot;foreach&quot;) library(&quot;doParallel&quot;) beta0 = c(1,-2,3) N = c(50,100,200) distribution= c(rnorm,rcauchy) SIM = 500 tstart=Sys.time() #cl &lt;- makeCluster(detectCores()) #registerDoParallel(cl) result &lt;- foreach(n=N,.combine = rbind) %:% foreach(dst=distribution,.combine = c) %:% foreach(i=1:SIM,.combine = &#39;+&#39;, .packages = c(&quot;MASS&quot;) )%do%{ sim_single(n,beta0,SLP=TRUE,mydist = dst) } #stopImplicitCluster() t.end=Sys.time() t.end-tstart ## Time difference of 38.65 secs result/SIM ## [,1] [,2] [,3] [,4] [,5] [,6] ## result.1 1.0086 -2.010 2.998 12.4454 -0.4945 0.05709 ## result.2 0.9932 -1.998 2.997 -0.6948 -3.1508 1.68111 ## result.3 0.9986 -2.003 3.001 0.8107 -1.7691 3.49674 4.2.4 模型选择 除了蒙特卡洛模拟之外,另外一个很适合并行的应用是模型选择.下面的例子用AIC对线性模型进行选择: AIClm &lt;- function(Y,X,ind){#单次计算AIC,ind为纳入模型的变量下标 AIC(lm(Y~X[,ind])) } gen_ind &lt;- function(bt, index) bt*index#生成候选模型下标 n = 100 p = 18 m0 = p%/%3 p0 = sample(1:p,m0) beta = rep(0,p) beta[p0] = 1:2 X &lt;- matrix(rnorm(n*p),n,p) Y &lt;- X%*%beta + rnorm(n) ##生成所有候选模型的下标 pl &lt;- 1:(2^p - 1) mt &lt;- matrix(0,2^p-1,p) for (i in pl) { mt[i,]=rev(as.integer(intToBits(i)[1:(p)] )) } index = 1:p lst = t(apply(mt, 1, gen_ind,index=index)) #并行 library(&quot;foreach&quot;) library(&quot;doParallel&quot;) tstart=Sys.time() cl &lt;- makeCluster(detectCores()) registerDoParallel(cl) foreach(i=1:(2^p-1),.combine = c) %dopar%{ AIClm(Y,X,lst[i,]) }-&gt;result stopImplicitCluster() t.end=Sys.time() t.end-tstart ## Time difference of 1.405 mins which(lst[which.min(result),]!=0) ## [1] 1 5 6 8 11 12 13 15 16 17 18 which(beta!=0) ## [1] 6 8 13 16 17 18 #串行 tstart=Sys.time() cl &lt;- makeCluster(detectCores()) registerDoParallel(cl) foreach(i=1:(2^p-1),.combine = c) %do%{ AIClm(Y,X,lst[i,]) }-&gt;result stopImplicitCluster() t.end=Sys.time() t.end-tstart ## Time difference of 3.495 mins which(lst[which.min(result),]!=0) ## [1] 1 5 6 8 11 12 13 15 16 17 18 which(beta!=0) ## [1] 6 8 13 16 17 18 4.3 Rcpp Rcpp提供了R与C++的无缝接口,可以很方便的在R中调用编写的C++程序. Rcpp文档 如何改写R程序 Rcpp已提供的分布函数 可以通过cppFunction直接在R中编写: Rcpp::cppFunction(&#39;int add(int x, int y, int z) { int sum = x + y + z; return sum; }&#39;) add ## function (x, y, z) ## .Call(&lt;pointer: 0x10af678f0&gt;, x, y, z) add(1, 2, 3) ## [1] 6 但是这种方式在编写(没有语法高亮)、调试(定位编译报错行号)时都有不便.推荐单独编写cpp文件,通过sourceCpp加载. 下面以矩阵按列求和为例,比较col_mean(自己编写的C++函数)11、colMeans(R base中提供的注重速度的函数)、mean_R(在R中用编写的函数)以及apply的运行速度. Rcpp::sourceCpp(&#39;code/Rcpp-demo.cpp&#39;) ## ## &gt; mean_R &lt;- function(X) { ## + n = dim(X)[1] ## + m = dim(X)[2] ## + cm &lt;- rep(0, m) ## + for (i in 1:n) { ## + cm = cm + X[i, ] ## + } ## + .... [TRUNCATED] m = 200 n = 100 X &lt;- matrix(rnorm(m*n),m,n) col_mean(X) -&gt; l1 mean_R(X) -&gt; l2 all.equal(l1,l2) ## [1] TRUE colMeans(X) -&gt; l3 all.equal(l1,l3) ## [1] TRUE apply(X, 2, mean) -&gt; l4 all.equal(l1,l4) ## [1] TRUE bench::mark( col_mean(X), colMeans(X), mean_R(X), apply(X, 2, mean), check = FALSE,relative = TRUE )-&gt;results ggplot2::autoplot(results) 对比结果如图所示,其中gc12是一个关于内存使用的指标,越低越好. apply和在R中用循环编写函数速度差不多,用C++编写的函数明显比其他快,甚至比base库中的函数还要快.不过,当我们增加矩阵的大小时,就会发现不一样的结果: Rcpp::sourceCpp(&#39;code/Rcpp-demo.cpp&#39;) ## ## &gt; mean_R &lt;- function(X) { ## + n = dim(X)[1] ## + m = dim(X)[2] ## + cm &lt;- rep(0, m) ## + for (i in 1:n) { ## + cm = cm + X[i, ] ## + } ## + .... [TRUNCATED] m = 2000 n = 1000 X &lt;- matrix(rnorm(m*n),m,n) col_mean(X) -&gt; l1 mean_R(X) -&gt; l2 all.equal(l1,l2) ## [1] TRUE colMeans(X) -&gt; l3 all.equal(l1,l3) ## [1] TRUE apply(X, 2, mean) -&gt; l4 all.equal(l1,l4) ## [1] TRUE bench::mark( col_mean(X), colMeans(X), mean_R(X), apply(X, 2, mean), check = FALSE,relative = TRUE )-&gt;results ggplot2::autoplot(results) 可以看到,还是base库中提供的函数速度最快. 4.3.1 RcppParallel C++并行库 官方文档 这里提供一个RcppParallel的例子: 核估计 下面是三个关于线性代数的库,https://gist.github.com/wolfv/ca3ac2b24e1daf70f85eac18ec7b1b8f 这个例子的测试结果表明xtensor最快 4.3.2 RcppArmadillo 线性代数库 官方文档 4.3.3 RcppEigen 线性代数库(更快一点,但是不友好) 官方文档 4.3.4 xtensor GitHub地址 程序在 这里 查看,其中最后被/***R */夹住的部分是R程序,每次加载后会自动执行,方便调试.↩ 垃圾回收（英语：Garbage Collection，缩写为GC），在计算机科学中是一种自动的存储器管理机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为垃圾回收。↩ "],
["sound.html", "A 余音绕梁", " A 余音绕梁 呐，到这里朕的书差不多写完了，但还有几句话要交待，所以开个附录，再啰嗦几句，各位客官稍安勿躁、扶稳坐好。 "],
["references.html", "参考文献", " 参考文献 "]
]
